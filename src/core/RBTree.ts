export type Color = 'RED' | 'BLACK';

export interface RBNode {
  id: number;
  value: number;
  color: Color;
  left: RBNode | null;
  right: RBNode | null;
  parentId: number | null; // Store ID for serialization safety
}

export interface Step {
  id: number;
  type: 'INSERT' | 'RECOLOR' | 'ROTATE' | 'ROOT_COLOR' | 'INFO' | 'COMPARE' | 'DELETE' | 'SEARCH' | 'TRAVERSE';
  description: string;
  treeSnapshot: RBNode | null; // The state of the tree AFTER this step
  highlightedNodeIds: number[]; // Nodes to highlight
  extraNode?: RBNode; // For nodes not yet in the tree (e.g. just created)
  operationId?: number;
  operationType?: string;
  traversingNodeId?: number; // Green circle showing current traversal position
  svg?: string; // SVG representation for visualization
  parenthesizationTree?: string; // Parenthesization tree SVG
  mTable?: string; // M table SVG
  sTable?: string; // S table SVG
}

export class RBTree {
  private root: RBNode | null = null;
  private steps: Step[] = [];
  private nextNodeId = 1;
  private stepCounter = 1;
  private currentOperationId: number | null = null;
  private operationCounter = 1;
  private operations: {
    id: number;
    type: string;
    keys: number[];
    startStepIndex: number;
    endStepIndex?: number;
  }[] = [];

  constructor() {}

  public search(value: number) {
    const initialStepCount = this.steps.length;
    let started = false;
    if (this.currentOperationId === null) {
      this.startOperation('SEARCH', [value]);
      started = true;
    }
    let current = this.root;
    
    this.addStep('SEARCH', `Searching for ${value}...`, []);

    while (current !== null) {
      this.addStep('TRAVERSE', `Comparing ${value} with ${current.value}`, [current.id], false, undefined, current.id);
      
      if (value === current.value) {
        this.addStep('SEARCH', `Found ${value}!`, [current.id]);
        return this.getStepsSince(initialStepCount);
      } else if (value < current.value) {
        if (current.left === null) {
           const nilId = -((current.id * 10) + 1);
           this.addStep('SEARCH', `${value} < ${current.value}. Reached NIL (not found).`, [nilId]);
        }
        current = current.left;
      } else {
        if (current.right === null) {
           const nilId = -((current.id * 10) + 2);
           this.addStep('SEARCH', `${value} > ${current.value}. Reached NIL (not found).`, [nilId]);
        }
        current = current.right;
      }
    }

    this.addStep('SEARCH', `${value} not found in the tree.`, []);
    if (started) this.endOperation();
    return this.getStepsSince(initialStepCount);
  }

  public insert(value: number) {
    // Clear steps for this operation if we want per-operation steps, 
    // but usually we want a cumulative history or just the steps for this insertion.
    // For this app, let's return the steps generated by this insertion.
    const initialStepCount = this.steps.length;
    let started = false;
    if (this.currentOperationId === null) {
      this.startOperation('INSERT', [value]);
      started = true;
    } else {
      // if already in an INSERT operation, append key to operation keys
      const op = this.operations.find(o => o.id === this.currentOperationId && o.type === 'INSERT');
      if (op) op.keys.push(value);
    }

    const newNode: RBNode = {
      id: this.nextNodeId++,
      value,
      color: 'RED',
      left: null,
      right: null,
      parentId: null,
    };

    if (this.root === null) {
      // For the very first insertion (root), show creation as RED then conversion to BLACK
      // For subsequent operations, skip the solo "insert as RED" step
      const isFirstEverInsertion = this.steps.length === 0;
      
      if (isFirstEverInsertion) {
        // Show the node being created as RED first (only for the very first insert)
        this.addStep('INSERT', `Insert ${value} as RED node`, [newNode.id], true, newNode);
      }

      // Make it the root (still RED for now) and show as added
      this.root = newNode;
      if (isFirstEverInsertion) {
        this.addStep('INSERT', `Add ${value} as ROOT (temporary RED)`, [newNode.id]);
      }

      // Next step: convert root to BLACK
      this.root.color = 'BLACK';
      this.addStep('ROOT_COLOR', `Make ${value} the ROOT and color it BLACK`, [newNode.id]);
      if (started) this.endOperation();
      return this.getStepsSince(initialStepCount);
    }

    // For non-root insertions, skip the solo "Insert X as RED node" step
    // (just do the BST insert directly)
    
    // Standard BST Insert
    let current: RBNode | null = this.root;
    let parent: RBNode | null = null;

    while (current !== null) {
      parent = current;
      this.addStep('TRAVERSE', `Comparing ${value} with ${current.value}`, [current.id], false, undefined, current.id);
      if (value < current.value) {
        if (current.left === null) {
            const nilId = -((current.id * 10) + 1);
            this.addStep('TRAVERSE', `${value} < ${current.value}. Found NIL. Inserting here.`, [nilId], false, undefined, current.id);
        }
        current = current.left;
      } else {
        if (current.right === null) {
            const nilId = -((current.id * 10) + 2);
            this.addStep('TRAVERSE', `${value} > ${current.value}. Found NIL. Inserting here.`, [nilId], false, undefined, current.id);
        }
        current = current.right;
      }
    }

    newNode.parentId = parent!.id;
    if (value < parent!.value) {
      parent!.left = newNode;
      this.addStep('INSERT', `Add ${value} as left child of ${parent!.value} as RED node`, [newNode.id]);
    } else {
      parent!.right = newNode;
      this.addStep('INSERT', `Add ${value} as right child of ${parent!.value} as RED node`, [newNode.id]);
    }

    this.fixInsert(newNode);
    if (started) this.endOperation();
    return this.getStepsSince(initialStepCount);
  }

  public delete(value: number) {
    const initialStepCount = this.steps.length;
    let started = false;
    if (this.currentOperationId === null) {
      this.startOperation('DELETE', [value]);
      started = true;
    } else {
      const op = this.operations.find(o => o.id === this.currentOperationId && o.type === 'DELETE');
      if (op) op.keys.push(value);
    }
    this.addStep('DELETE', `Starting deletion of ${value}`, []);
    
    const z = this.findNodeByValue(value);
    if (!z) {
      this.addStep('DELETE', `Node ${value} not found, cannot delete`, []);
      return this.getStepsSince(initialStepCount);
    }

    this.addStep('DELETE', `Found node ${value} to delete`, [z.id]);

    let y = z; // Node to be removed or moved
    let yOriginalColor = y.color;
    let x: RBNode | null; // Child of y
    let xParentId: number | null = null; // Parent of x (needed if x is null)

    if (z.left === null) {
      x = z.right;
      xParentId = z.parentId; // If z is removed, x's parent becomes z's parent
      this.transplant(z, z.right);
      this.addStep('DELETE', `Node has no left child, replacing with right child`, x ? [x.id] : []);
    } else if (z.right === null) {
      x = z.left;
      xParentId = z.parentId;
      this.transplant(z, z.left);
      this.addStep('DELETE', `Node has no right child, replacing with left child`, x ? [x.id] : []);
    } else {
      // Two children case
      y = this.minimum(z.right);
      yOriginalColor = y.color;
      x = y.right;
      
      if (y.parentId === z.id) {
        xParentId = y.id; // x's parent is y
      } else {
        xParentId = y.parentId;
        this.transplant(y, y.right);
        y.right = z.right;
        if (y.right) y.right.parentId = y.id;
      }
      
      this.transplant(z, y);
      y.left = z.left;
      if (y.left) y.left.parentId = y.id;
      y.color = z.color;
      this.addStep('DELETE', `Replaced ${z.value} with successor ${y.value}`, [y.id]);
    }

    if (yOriginalColor === 'BLACK') {
      this.addStep('DELETE', `Deleted node was BLACK, fixing double black...`, []);
      this.fixDelete(x, xParentId);
    } else {
      this.addStep('DELETE', `Deleted node was RED, no fixup needed`, []);
    }
    if (started) this.endOperation();
    return this.getStepsSince(initialStepCount);
  }

  // Operation helpers
  public startOperation(type: string, keys: number[] = []) {
    const id = this.operationCounter++;
    this.currentOperationId = id;
    this.operations.push({ id, type, keys: [...keys], startStepIndex: this.steps.length });
    return id;
  }

  public endOperation() {
    if (this.currentOperationId === null) return;
    const op = this.operations.find(o => o.id === this.currentOperationId);
    if (op) {
      op.endStepIndex = this.steps.length - 1;
      
      // Add a completion step
      const opType = op.type === 'INSERT' ? 'insertions' : op.type === 'DELETE' ? 'deletions' : 'operations';
      this.addStep('INFO', `Red-Black Tree is now complete with successful ${opType}`, []);
    }
    this.currentOperationId = null;
  }

  public getOperations() {
    return this.operations.slice();
  }

  private fixDelete(x: RBNode | null, xParentId: number | null) {
    let current = x;
    let parentId = xParentId;

    while ((!current || current.color === 'BLACK') && current !== this.root) {
      if (!parentId) break; // Should be root
      
      const parent = this.findNode(parentId);
      if (!parent) break;

      if (current === parent.left) {
        let w = parent.right; // Sibling
        
        if (w && w.color === 'RED') {
          // Case 1: Sibling is RED
          w.color = 'BLACK';
          parent.color = 'RED';
          this.addStep('RECOLOR', `Case 1: Sibling is RED. Recolor sibling and parent`, [w.id, parent.id]);
          this.rotateLeft(parent);
          this.addStep('ROTATE', `Case 1: Rotate Left on parent`, [parent.id]);
          w = parent.right;
        }

        if ((!w || !w.left || w.left.color === 'BLACK') && (!w || !w.right || w.right.color === 'BLACK')) {
          // Case 2: Sibling's children are BLACK
          if (w) w.color = 'RED';
          this.addStep('RECOLOR', `Case 2: Sibling's children are BLACK. Recolor sibling to RED`, w ? [w.id] : []);
          current = parent;
          parentId = parent.parentId;
        } else {
          if (!w || !w.right || w.right.color === 'BLACK') {
            // Case 3: Sibling's right child is BLACK (so left is RED)
            if (w && w.left) w.left.color = 'BLACK';
            if (w) w.color = 'RED';
            this.addStep('RECOLOR', `Case 3: Sibling's right child is BLACK. Recolor sibling and its left child`, w ? [w.id] : []);
            if (w) this.rotateRight(w);
            this.addStep('ROTATE', `Case 3: Rotate Right on sibling`, w ? [w.id] : []);
            w = parent.right;
          }

          // Case 4: Sibling's right child is RED
          if (w) {
            w.color = parent.color;
            parent.color = 'BLACK';
            if (w.right) w.right.color = 'BLACK';
            this.addStep('RECOLOR', `Case 4: Recolor sibling, parent, and sibling's right child`, [w.id, parent.id]);
            this.rotateLeft(parent);
            this.addStep('ROTATE', `Case 4: Rotate Left on parent`, [parent.id]);
          }
          current = this.root;
          parentId = null;
        }
      } else {
        // Mirror cases
        let w = parent.left;

        if (w && w.color === 'RED') {
          w.color = 'BLACK';
          parent.color = 'RED';
          this.addStep('RECOLOR', `Case 1 (Mirror): Sibling is RED. Recolor sibling and parent`, [w.id, parent.id]);
          this.rotateRight(parent);
          this.addStep('ROTATE', `Case 1 (Mirror): Rotate Right on parent`, [parent.id]);
          w = parent.left;
        }

        if ((!w || !w.right || w.right.color === 'BLACK') && (!w || !w.left || w.left.color === 'BLACK')) {
          if (w) w.color = 'RED';
          this.addStep('RECOLOR', `Case 2 (Mirror): Sibling's children are BLACK. Recolor sibling to RED`, w ? [w.id] : []);
          current = parent;
          parentId = parent.parentId;
        } else {
          if (!w || !w.left || w.left.color === 'BLACK') {
            if (w && w.right) w.right.color = 'BLACK';
            if (w) w.color = 'RED';
            this.addStep('RECOLOR', `Case 3 (Mirror): Sibling's left child is BLACK. Recolor sibling and its right child`, w ? [w.id] : []);
            if (w) this.rotateLeft(w);
            this.addStep('ROTATE', `Case 3 (Mirror): Rotate Left on sibling`, w ? [w.id] : []);
            w = parent.left;
          }

          if (w) {
            w.color = parent.color;
            parent.color = 'BLACK';
            if (w.left) w.left.color = 'BLACK';
            this.addStep('RECOLOR', `Case 4 (Mirror): Recolor sibling, parent, and sibling's left child`, [w.id, parent.id]);
            this.rotateRight(parent);
            this.addStep('ROTATE', `Case 4 (Mirror): Rotate Right on parent`, [parent.id]);
          }
          current = this.root;
          parentId = null;
        }
      }
    }

    if (current) {
      current.color = 'BLACK';
      this.addStep('RECOLOR', `Fixup complete. Ensure current node is BLACK`, [current.id]);
    }
  }

  private transplant(u: RBNode, v: RBNode | null) {
    if (u.parentId === null) {
      this.root = v;
    } else {
      const parent = this.findNode(u.parentId);
      if (parent) {
        if (u === parent.left) {
          parent.left = v;
        } else {
          parent.right = v;
        }
      }
    }
    if (v) {
      v.parentId = u.parentId;
    }
  }

  private minimum(node: RBNode): RBNode {
    let current = node;
    while (current.left !== null) {
      current = current.left;
    }
    return current;
  }

  private findNodeByValue(value: number): RBNode | null {
    let current = this.root;
    while (current !== null) {
      if (value === current.value) return current;
      if (value < current.value) current = current.left;
      else current = current.right;
    }
    return null;
  }

  private fixInsert(node: RBNode) {
    let k = node;

    while (k.parentId !== null) {
      let parent = this.findNode(k.parentId);
      if (!parent || parent.color === 'BLACK') break;

      // Parent is RED, so we have a violation.
      // We need the grandparent.
      let grandparent = parent.parentId ? this.findNode(parent.parentId) : null;
      if (!grandparent) break; // Should not happen if parent is RED (root is black)

      if (parent === grandparent.left) {
        let uncle = grandparent.right;

        if (uncle && uncle.color === 'RED') {
          // Case 1: Uncle is RED
          parent.color = 'BLACK';
          uncle.color = 'BLACK';
          grandparent.color = 'RED';
          this.addStep('RECOLOR', `Recolor parent (${parent.value}) and uncle (${uncle.value}) to BLACK, grandparent (${grandparent.value}) to RED`, [parent.id, uncle.id, grandparent.id]);
          k = grandparent;
        } else {
          // Case 2 & 3: Uncle is BLACK or NULL
          if (k === parent.right) {
            // Case 2: Triangle -> Rotate Left
            k = parent;
            this.rotateLeft(k);
            this.addStep('ROTATE', `Rotate Left on ${k.value}`, [k.id]);
            // Update parent reference after rotation
             parent = this.findNode(k.parentId!); // k's new parent
             grandparent = parent && parent.parentId ? this.findNode(parent.parentId) : null;
          }
          
          // Case 3: Line -> Rotate Right + Recolor
          if (parent) {
            parent.color = 'BLACK';
            if (grandparent) {
              grandparent.color = 'RED';
              this.addStep('RECOLOR', `Recolor parent (${parent.value}) to BLACK, grandparent (${grandparent.value}) to RED`, [parent.id, grandparent.id]);
              this.rotateRight(grandparent);
              this.addStep('ROTATE', `Rotate Right on ${grandparent.value}`, [grandparent.id]);
            }
          }
        }
      } else {
        // Mirror of above (Parent is right child)
        let uncle = grandparent.left;

        if (uncle && uncle.color === 'RED') {
          parent.color = 'BLACK';
          uncle.color = 'BLACK';
          grandparent.color = 'RED';
          this.addStep('RECOLOR', `Recolor parent (${parent.value}) and uncle (${uncle.value}) to BLACK, grandparent (${grandparent.value}) to RED`, [parent.id, uncle.id, grandparent.id]);
          k = grandparent;
        } else {
          if (k === parent.left) {
            k = parent;
            this.rotateRight(k);
            this.addStep('ROTATE', `Rotate Right on ${k.value}`, [k.id]);
             parent = this.findNode(k.parentId!);
             grandparent = parent && parent.parentId ? this.findNode(parent.parentId) : null;
          }
          
          if (parent) {
            parent.color = 'BLACK';
            if (grandparent) {
              grandparent.color = 'RED';
              this.addStep('RECOLOR', `Recolor parent (${parent.value}) to BLACK, grandparent (${grandparent.value}) to RED`, [parent.id, grandparent.id]);
              this.rotateLeft(grandparent);
              this.addStep('ROTATE', `Rotate Left on ${grandparent.value}`, [grandparent.id]);
            }
          }
        }
      }
    }

    if (this.root && this.root.color === 'RED') {
      this.root.color = 'BLACK';
      this.addStep('ROOT_COLOR', `Ensure ROOT (${this.root.value}) is BLACK`, [this.root.id]);
    }
  }

  private rotateLeft(node: RBNode) {
    const rightChild = node.right;
    if (!rightChild) return;

    node.right = rightChild.left;
    if (node.right) {
      node.right.parentId = node.id;
    }

    rightChild.parentId = node.parentId;
    if (node.parentId === null) {
      this.root = rightChild;
    } else {
      const parent = this.findNode(node.parentId);
      if (parent) {
        if (node === parent.left) {
          parent.left = rightChild;
        } else {
          parent.right = rightChild;
        }
      }
    }

    rightChild.left = node;
    node.parentId = rightChild.id;
  }

  private rotateRight(node: RBNode) {
    const leftChild = node.left;
    if (!leftChild) return;

    node.left = leftChild.right;
    if (node.left) {
      node.left.parentId = node.id;
    }

    leftChild.parentId = node.parentId;
    if (node.parentId === null) {
      this.root = leftChild;
    } else {
      const parent = this.findNode(node.parentId);
      if (parent) {
        if (node === parent.right) {
          parent.right = leftChild;
        } else {
          parent.left = leftChild;
        }
      }
    }

    leftChild.right = node;
    node.parentId = leftChild.id;
  }

  private findNode(id: number): RBNode | null {
    // Simple BFS or DFS to find node by ID
    if (!this.root) return null;
    const queue = [this.root];
    while (queue.length > 0) {
      const current = queue.shift()!;
      if (current.id === id) return current;
      if (current.left) queue.push(current.left);
      if (current.right) queue.push(current.right);
    }
    return null;
  }

  // Helper to calculate the black height of a subtree
  private calculateBlackHeight(node: RBNode | null): number {
    if (!node) return 1; // NIL nodes contribute 1 to black height
    const leftBlackHeight = this.calculateBlackHeight(node.left);
    const rightBlackHeight = this.calculateBlackHeight(node.right);

    if (leftBlackHeight !== rightBlackHeight) {
      throw new Error(`Black height violation at node ${node.value}: left (${leftBlackHeight}) != right (${rightBlackHeight})`);
    }

    return leftBlackHeight + (node.color === 'BLACK' ? 1 : 0);
  }

  // Updated addStep to include black height validation
  private addStep(
    type: Step['type'],
    description: string,
    highlightedNodeIds: number[] = [],
    skipSnapshot = false,
    extraNode?: RBNode,
    traversingNodeId?: number
  ) {
    // Validate black height before adding the step
    if (this.root) {
      try {
        const blackHeight = this.calculateBlackHeight(this.root);
        description += `\nBlack height: ${blackHeight}`;
      } catch (error) {
        // Ensure error is treated as an Error object
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        description += `\nError: ${errorMessage}`;
      }
    }

    const opId = this.currentOperationId;
    const opType = opId ? this.operations.find((o) => o.id === opId)?.type : undefined;
    this.steps.push({
      id: this.stepCounter++,
      type,
      description,
      treeSnapshot: skipSnapshot ? null : this.cloneTree(this.root),
      highlightedNodeIds,
      extraNode: extraNode ? (this.cloneTree(extraNode) as RBNode) : undefined,
      operationId: opId ?? undefined,
      operationType: opType ?? undefined,
      traversingNodeId: traversingNodeId,
    });
  }

  private cloneTree(node: RBNode | null): RBNode | null {
    if (!node) return null;
    return {
      ...node,
      left: this.cloneTree(node.left),
      right: this.cloneTree(node.right)
    };
  }

  private getStepsSince(index: number) {
    return this.steps.slice(index);
  }

  public getAllSteps() {
    return this.steps;
  }
  
  public reset() {
      this.root = null;
      this.steps = [];
      this.nextNodeId = 1;
      this.stepCounter = 1;
  }
}
